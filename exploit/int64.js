/*
 * Library allowing to work with 64-bit integers in JavaScript.
 * Heavily based on @5aelo's own Int64.js library.
 *
 * Lyte <lyte@lyte.rs>
 *
 */


class Int64 {

    constructor(value) {
        this._bytes = new Uint8Array(8);
        switch (typeof value) {
            case 'number':
                if (Number(value) === value && value % 1 === 0
                    && value >= 0 && value <= Number.MAX_SAFE_INTEGER) {
                    value = '0x' + value.toString(16);
                }
                else {
                    value = value.toString()
                }
            case 'string':
                var reDoubleStr = '^\\-?[0-9]+$' + '|' +
                                  '^\\-?[0-9e]+e\\-?[0-9]+$' + '|' +
                                  '^\\-?[0-9e]+\\.[0-9]+(e\\-?[0-9]+)?$';
                var reDouble = new RegExp(reDoubleStr);
                var doubleValue = value.match(reDouble);
                if (doubleValue) {
                    value = parseFloat(value);
                    this._bytes = this._toFloatArray(value);
                    break;
                }

                var reHexStr = '^0x[0-9a-fA-F]{1,16}$';
                var reHex = new RegExp(reHexStr);
                var hexValue = value.match(reHex)[0];
                if (hexValue) {
                    value = value.slice(2);
                    value = (Array(16).join("0") + value).slice(-16);
                    this._bytes = this._bytes.map(
                        (_, i) => parseInt(value.slice(16-(i+1)*2, 16-i*2), 16)
                    );
                    break;
                }
                throw new TypeError("Invalid argument format");
            case 'object':
                if (value instanceof Int64)
                    this._bytes.set(value.bytes);
                else if (value instanceof Array) {
                    if (value.length > 8)
                        throw new TypeError("Invalid array size");
                    this._bytes.set(value);
                }
                else
                    throw new TypeError("Invalid argument type (object)");
                break;
            default:
                throw new TypeError("Invalid argument type (default)");
        }
    }

    get double() {
        return this._toDouble(this._bytes);
    }

    get hex() {
        return this._toHex(this._bytes);
    }

    get bytes() {
        return this._bytes;
    }

    set bytes(bytes) {
        this._bytes = bytes;
    }

    toString() {
        return this.hex;
    }

    add(value) {
        return this._doOperation(this._opAdd, value);
    }

    sub(value) {
        return this._doOperation(this._opSub, value);
    }

    xor(value) {
        return this._doOperation(this._opXor, value);
    }

    _opAdd(elem1, elem2, carry, i) {
        var current_sum = elem1[i] + elem2[i] + carry;
        carry = current_sum > 0xff | 0;
        elem1[i] = current_sum & 0xff;
        return carry;
    }

    _opSub(elem1, elem2, carry, i) {
        var current_sum = elem1[i] - elem2[i] - carry;
        carry = current_sum < 0 | 0;
        elem1[i] = current_sum & 0xff;
        return carry;
    }

    _opXor(elem1, elem2, _, i) {
        elem1[i] = elem1[i] ^ elem2[i];
        return 0;
    }

    _doOperation(op, value) {
        var current_sum, carry = 0;
        var valueBytes = new Int64(value).bytes;
        var result = new Int64(this);
        result.bytes.map(
            (_, i) => carry = op(result.bytes, valueBytes, carry, i)
        );
        return result;
    }

    _toFloatArray(double) {
        var floatArray = new Float64Array([double]);
        return new Uint8Array(floatArray.buffer);
    }

    _toDouble(array) {
        var floatArray = new Float64Array(array.buffer);
        var double = floatArray[0];
        if (Number.isNaN(double))
            throw new RangeError("64-bit value cannot be converted to double");
        return floatArray[0];
    }

    _toHex(array) {
        var hexStr = "";
        if (String(this._toDouble(array)).indexOf('.') > 0) {
            const get_hex = i => ('00' + i.toString(16)).slice(-2);
            var result = Array.apply(0, { length: 8 })
                              .map((_, i) => get_hex(array[7-i]))
                              .join('');
            hexStr = "0x" + result;
        }
        else {
            var value = this._toDouble(array);
            var valueStr = value.toString();
            var reDoubleStr = '^\\-?[0-9e]+e\\-?[0-9]+$' + '|' +
                              '^\\-?[0-9e]+\\.[0-9]+(e\\-?[0-9]+)?$';
            var reDouble = new RegExp(reDoubleStr);
            var doubleValue = valueStr.match(reDouble);
            if (doubleValue)
                throw new RangeError("64-bit value cannot be converted to hex");
            if (value < 0)
                hexStr += "-"
            hexStr += "0x" + Math.abs(value).toString(16);
        }
        return hexStr;
    }
}
